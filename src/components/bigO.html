<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title></title>
  <style>
  html{
    background:#A8a2E1;
    color:olive;
  }
  pre{
    border:#A8a2F2;
    border-style:dotted ;
    color:white;
    background:orange;
    padding:2%;
  }
  .post {
    padding: 2%;
    padding-right:50%
  }
  ol, ul, .content{
    text-align:left;
    border:white;
    border-style:solid ;
    border-radius:5px;
    width:50%;
    margin:1%;
    padding:1%;
  }  post-header{
    text-align: center;
  }

  </style>
</head>
<body>
  <header class="post-header">
    <p>| <a href="../../index.html">Home</a> | <a href="thoughts.html">Thoughts</a>
    <h4>Big O Notation</h4>
<em>  November 27, 2020 </em>
  </header>

<div class="content">
<h3>Big O</h3>
<p>Big O notation is the language we use when talking about the effeciency of an algorithm. </p>
<p>Big O notation expresses runtime relative to the input</p>
<p>This is a tooling we use to make an estimate of the run time. There isn't a precise way because there are many variables that it depends on that can vary by machine.So we use Big O notation to talk about how quickly it may grow </p>
<p>
  This measurement is a reference to the size of the input, so instead of measuring through time in secs we instead refer to the size of the input.
</p>
<p>
It's almost like going to the grocery, you have your basket full of goodies, but you are on a budget. While waiting in line to pay, you make an estimate of your "runtime"/ "total". Since you cant ring up the exact price, you have to play a little game of "the price is right".

If your basket is over your budget you may have to refactor your ingredients.
Lets say you have a jar of pesto. You were feeling a bit lazy today, and perhaps didn't exactly want to make pesto by scratch. But to optimize your shopping algorithm you instead bought the ingredients to make it instead.

When making decisions we need to have priorities. Are we favoring time, space, or convenience? How can we execute our goal, sometimes it takes some clever maneuvering.
</p>
<p>
  Sometimes over optimizing for big O standards can impact readability, conviencence, or time spent writing code. I think it is best to get it working with brute force initally, then allow margin for optimization. There are many variables to account for a good balance between runtime, space, implementation time, maintainability, and readability.
</p>
<pre>
  <code>
    public static void printFirstItem(int[] items) {
  System.out.println(items[0]);
}
  </code>
</pre>
<p>
This method runs in <em>O(1) time or "Constant Time"</em> Relative to the input.
</p>
<p>
The input can hold an array of 1, or 1,000,000,000 but this method would only require one step
</p>

<pre>
  <code>
    public static void printAllItems(int[] items) {
    for (int item : items) {
        System.out.println(item);
    }
}
  </code>
</pre>
<p>
   This method runs in <em>O(n) time or "Linear Time"</em>
</p>
<p>n is the number of items in the array. If there is 100 items, this method would have to print 100 times.</p>

<pre>
  <code>
    public static void printAllPossibleOrderedPairs(int[] items) {
    for (int firstItem : items) {
        for (int secondItem : items) {
            System.out.println(firstItem + ", " + secondItem);
        }
    }
}
  </code>
</pre>
<p>
  Here is two loops one nested within another. If our array has n items, our outer loop will run n times and our inner loop will run n times. Giving us n^2 total iterations. This method will run <em>O(n^2)time or "quadratic time"</em>
  <p>If this array has 10 items, we have to print 100 times.
  </p>
</p>
</div>
<div class="content">
<h3>Sometimes the input can be n, or the size of n</h3>
<p>When n is the input or size, that means the runtime will be <em>O(n)</em></p>
<pre>
  <code>
    public static void sayHiNTimes(int n) {
    for (int i = 0; i < n; i++) {
        System.out.println("hi");
    }
}

public static void printAllItems(int[] items) {
    for (int item : items) {
        System.out.println(item);
    }
}

  </code>
</pre>
</div>
<div class="content">
  <h3>Dropping the constants</h3>
  <p>In Big-O notation we oftern drop the constants</p>
  <pre>
    <code>
      public static void printAllItemsTwice(int[] items) {
    for (int item : items) {
        System.out.println(item);
    }

    // once more, with feeling
    for (int item : items) {
        System.out.println(item);
    }
}
    </code>
  </pre>
  <p> This is <em>O(2n) runtime</em></p>
  <p> We just call it <em>O(n)</em></p>
  <p> This method runs <em>O(n)</em> twice, but we can skim the 2 off</p>
  <pre>
    <code>
      public static void print(int[] items) {
    System.out.println(items[0]);

    int middleIndex = items.length / 2;
    int index = 0;

    while (index < middleIndex) {
        System.out.println(items[index]);
        index++;
    }
    for (int i = 0; i < 100; i++) {
        System.out.println("hi");
    }
}
    </code>
  </pre>
  <p>
    This is <em>O(1+n/2+100)</em> We can just call that <em>O(n)</em>
  </p>
  <p> We are looking if this data set is significally larger, adding 100 or dividing by 2 wouldnt be too much of a burden if n  </p>
</div>
<div class="content">
<h3>
  WORST CASE SCENARIOS
</h3>
  <p>
    There are times where the worst case scenario can be severely worst than the best case scenario. So be skeptical of quickly walking away with the algorithm that has a good runtime at first glance, be thourough in your BIG O diagnostic.
  </p>
  <pre>
    <code>

public static boolean contains(int[] haystack, int needle) {

    // does the haystack contain the needle?
    for (int n : haystack) {
        if (n == needle) {
            return true;
        }
    }

    return false;
}
    </code>
  </pre>
  <p>
    Lets say there are 100 items in this array, if the first index is the needle. The best case scenario would just iterate 1 time. We can say the best case is <em>O(1)</em>, and the worst case is <em>O(n) runtime</em> Since the foor loop had to iterate through the whole array.
  </p>
</div>
<div class="content">
  <h3> Space complexities</h3>
  <p> Memory cost = Space complexity</p>
  <p> It is pretty similar to time cost.</p>
  <p>We need to sometimes optimize our code to use less memory, and less time. In order to do that we take a look at the total size of all the new variables we are creating in space, in reference to the input size</p>
  <pre>
    <code>
    public static void sayHiNTimes(int n) {
    for (int i = 0; i < n; i++) {
        System.out.println("hi");
    }
}
    </code>
  </pre>
  <p>This method take <em>O(1) space since the the variable is fixed, and streaming directly through the input without external allocation</em> </p>
  <pre>
    <code>
      public static String[] arrayOfHiNTime(int n) {
        String[] hiArray = new String[n];
        for(int i = 0; i< n; i++){
          hiArray[i] = "hi";
        }
        return hiArray;
      }
    </code>
  </pre>
  <p> This method takes <em>O(n) space because the array is in scale with the size of the input n</em></p>
</div>

</body>
<footer>
 <p>Author: Michael Rodriguez</p>
  <p>Code examples referenced from interview cake</p>
</footer>
</html>
